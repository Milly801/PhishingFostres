import logging
logger = logging.getLogger("phishfortress.user_routes")

print("[DEBUG] user_routes.py loaded")
from pydantic import BaseModel
from fastapi import APIRouter, Depends, HTTPException, Header, Request
from fastapi.security import HTTPAuthorizationCredentials
from server.repositories.user_repository import UserRepository
from server.services.auth_service import verify_jwt, get_user_info
from server.models.user_model import User
import requests

router = APIRouter(
    prefix = "/users",
    tags= ["Users"]
)

@router.post("/auth/signup")
async def signup(authorization:str = Header(...)):
    user_repository = None
    try:
        if not authorization.startswith("Bearer "):
            raise HTTPException(status_code=401, detail="No auth header")
        token = authorization.split(" ")[1]
        credentials = HTTPAuthorizationCredentials(
            scheme="Bearer", credentials=token)
        decoded_token = verify_jwt(credentials)

        user_info = get_user_info(token)
        auth0_id = decoded_token["sub"]
        email = user_info["email"]

        user_data = {"email": email, "auth0_id":auth0_id}
        user_repository = UserRepository()
        # Check if user exists
        existing_user = user_repository.get_user_by_email(email)
        if existing_user:
            return {
                "id": existing_user.id,
                    "auth0_id": existing_user.auth0_id,
                "email": existing_user.email
            }
        # If not, create new user
        new_user = user_repository.create_user(user_data)
        return {
            "id": new_user.id,
            "auth0_id": new_user.auth0_id,
            ""
            "email": new_user.email
        }
    except Exception as e:
        raise
    finally:
        if user_repository:
            user_repository.db_session.close()
    
@router.get("/")
async def get_all_users():
    try:
        user_repository = UserRepository()
        users = user_repository.get_all_users()
        return {"users": [user.to_dict() for user in users]}  # Assuming `to_dict()` exists in your User model
    except Exception as e:
        logger.error(f"Error fetching all users: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")
    finally:
        user_repository.db_session.close()

@router.get("/{user_id}")
async def get_user_by_id(user_id: str):
    try:
        user_repository = UserRepository()
        user = user_repository.get_user_by_id(user_id)
        if not user:
            raise HTTPException(status_code=404, detail="User not found")
        return user.to_dict()  # Assuming `to_dict()` exists in your User model
    except Exception as e:
        logger.error(f"Error fetching user by ID: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")
    finally:
        user_repository.db_session.close()

class CreateUserRequest(BaseModel):
    email: str
    auth0_id: str

@router.post("/")
async def create_user(user_data: CreateUserRequest):
    try:
        user_repository = UserRepository()
        new_user = user_repository.create_user(user_data.dict())
        return new_user.to_dict()  # Assuming `to_dict()` exists in your User model
    except Exception as e:
        logger.error(f"Error creating user: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")
    finally:
        user_repository.db_session.close()

class UpdateUserRequest(BaseModel):
    email: str = None
    auth0_id: str = None

@router.put("/{user_id}")
async def update_user(user_id: str, updated_data: UpdateUserRequest):
    try:
        user_repository = UserRepository()
        updated_user = user_repository.update_user(user_id, updated_data.dict(exclude_unset=True))
        if not updated_user:
            raise HTTPException(status_code=404, detail="User not found")
        return updated_user.to_dict()  # Assuming `to_dict()` exists in your User model
    except Exception as e:
        logger.error(f"Error updating user: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")
    finally:
        user_repository.db_session.close()

@router.delete("/{user_id}")
async def delete_user(user_id: str):
    try:
        user_repository = UserRepository()
        success = user_repository.delete_user(user_id)
        if not success:
            raise HTTPException(status_code=404, detail="User not found")
        return {"message": "User deleted successfully"}
    except Exception as e:
        logger.error(f"Error deleting user: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")
    finally:
        user_repository.db_session.close()

   
"""not needed anymore
@router.post("/auth/login")
async def login(authorization:str = Header(...)):
    user_repository = None
    try:
        logger.debug("/auth/login called")
        if not authorization.startswith("Bearer "):
            logger.error("No auth header or wrong format")
            raise HTTPException(status_code=401, detail="No auth header")
        token = authorization.split(" ")[1]
        logger.debug(f"Token extracted: {token[:10]}...")
        credentials = HTTPAuthorizationCredentials(
            scheme="Bearer", credentials=token)
        decoded_token = verify_jwt(credentials)
        user_info = await get_user_info(token)
        logger.debug(f"Decoded token: {decoded_token}")
        logger.debug(f"User info from Auth0: {user_info}")
        email = user_info["email"]
        if not email:
            logger.error("No email provided in user info")
            raise HTTPException(status_code=401, detail="No email provided")

        user_repository = UserRepository()
        existing_user = await user_repository.get_user_by_email(email)
        if not existing_user:
            logger.warning(f"User not found for email: {email}")
            raise HTTPException(status_code=404, detail="User not found")
        logger.info(f"Login successful for user: {email}")
        return {
            "message": "Login successful!"
        }
    except Exception as e:
        logger.error(f"Exception in /auth/login: {e}")
        raise HTTPException(status_code=500, detail=str(e))
    finally:
        if user_repository:
            user_repository.db_session.close()
"""
